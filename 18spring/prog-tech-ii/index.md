---
type: tasks
---

## Многопоточное программирование

1. Используйте `AtomicInteger` вместо synchronized блока для решения задачи про бананы и мартышек.
1. Многопоточный фрактал
    1. Добавьте в задачу с фракталом `ProgressBar` внизу окна.
    1. Пусть каждое вычиление фрактала производится в отдельном `Task`.
    1. Пусть во время вычисления фрактала обновляется ProgressBar.
    1. Если начал работать `Task` для вычисления фрактала, при этом аналогичный `Task` уже работает, предудущий нужно отменить.
       Используйте метод `cancel()` для отмены, и внутри `Task` завершите вычисления, если `isCancelled()` возвращает `true`.
    1. Пусть после вычисления очередной строки (столбца) фрактала `Task` обновляет вычисленное значение методом `updateValue`,
       и программа сразу показывает обновленное значение. В этом случае рисование фрактала на экране будет происходить постепенно,
       а не скачком.

## JSON

1. Создайте класс `Author` с полями `name` и `surname`. Пусть теперь в Book поле `author` имеет тип `Author`. Измените json, чтобы программа
   могла правильно прочитать книги.
1. Дано слово `String word = "..."` и два языка: `String from = "..."` и `String to = "..."`. Переведите с слово с одного языка
   на другой с помощью [glosbe.com](http://glosbe.com). Выведите в консоль исходное слово, все переводы, для каждого первода — все смыслы.
   После этого для каждого перевода укажите источник.
   
## Jar файлы

1. Создайте запускаемый jar файл из своей задачи про фракталы.
1. Необязательно: добавьте в задачу про фракталы иконку в виде ресурса.

## Потоки (Streams)

1. Создайте метод getTokenStream, который для заданного файла возвращает поток слов в этом файле.
    1. Простой способ: прочитайте весь файл в память в виде одной строки (используйте вспомогательные функции из класса `Files`),
    и вызовите для полученной строки метод `split()`.
    1. Сложнее. Создайте `Scanner` и воспользуйтесь методом `Stream.generate()` для создания потока.
1. Посчитайте количество слов в потоке.
1. Посчитайте количество слов в потоке без учета [стоп-слов](https://raw.githubusercontent.com/stopwords-iso/stopwords-ru/master/stopwords-ru.txt). Подсказка: создайте Set<String> для списка стоп-слов.
1. Посчитайте частоты всех слов файла.
1. Выведите слова в порядке убывания частот. Подсказка. У `Map` есть метод `entrySet` который возвращает множество (`Set`) записей, содержащих пару из ключа и значения. С этим множеством тоже можно работать с помощью потоков, и сортировать его.
1. Пусть S = количество стоп-слов. Если взять первые S самых частотных слов вашего текста, сколько совпадений будет со словами стоп-листа?
1. Какая средняя длина слова в вашем тексте? А максимальная, минимальная, дисперсия? Подсказка: для вычисления сразу всех статистик
   есть соответствующий `Collector`.
1. Сложно. Определите имена в тексте. Имена — это слова, начинающиеся с заглавной буквы, перед которыми не было конца предложения, т.е. точки, запятой, вопросительного знака.
1. Сложно. Создайте класс `Context`. Он содержит `String` word — слово и `Set<String>` — несколько соседних слов, пять до и пять после. (5 — это константа, которую можно менять при создании класса). Превратите поток слов в поток их контекстов.
