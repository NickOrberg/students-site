---
type: tasks
---
# Задания по пакету Octave

### Базовые задания `octave-1`

Загрузите в папку octave-1 три файла `task1.m`, `task2.m`, `task3.m`, которые мы делали на практике.

### Создание матриц `octave-matrices`

Создайте указанные матрицы. В этих задачах нельзя использовать циклы. И вы должны избежать ручного ввода элементов матрицы, вместо этого используйте возможности Octave по конструированию матриц. Т.е., например, если вас попросили создать матрицу 10 на 10, не перечисляейте в решении все 100 элементов этой матрицы. Т.е. представьте, что вас просят на самом деле создавать матрицы 1000 на 1000. Маленькие матрицы в условии нужны для того, чтобы вам было проще отладить свою программу, увидев матрицы на экране целиком.
1. Создайте матрицу 10 на 10, у которой все элементы нули, кроме первой строки, в которой все элементы единицы
1. Создайте матрицу 10 на 10, у которой в каждой клетке стоит 0 или 1 в шахматном порядке:
```
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    ...
```    
1. Матрица 9 на 9, вся первая строка состоит из единиц, вторая строка состоит из двоек, третья — из троек и т.д.
1. Создайте матрицу 10 на 10 с подряд идущими числами от 1 до 100
```
     1  2  3  4  5  6  7  8  9 10
    11 12 13 14 15 16 17 18 19 20
    21 22 23 24 25 26 27 28 29 30
    ...
   ``` 
1. "Таблица умножения". Матрица 9 на 9, где в каждой клетке стоит произведение номера столбца на номер строки:
```
     1  2  3  4  5  6  7  8  9
     2  4  6  8 10 12 14 16 18
     ...
   ```  
1. Даны числа n, a, b. Создайте матрицу размера n на n, у которой на главной диагонали стоят числа a, а строго над и под главной диагональю стоят числа b. Остальные числа матрицы — нули. Пример для аргументов (4, 1, 2):
```
    1 2 0 0
    2 1 2 0
    0 2 1 2
    0 0 2 1
   ``` 
1. Вспомните задачу 2. Там еще 1 и 0 в были в шахматном порядке. Создайте теперь матрицу 20 на 20, только теперь «клеточки» должны быть два на два:
```
    0 0 1 1 0 0 .....
    0 0 1 1 0 0 .....
    1 1 0 0 1 1 .....
    1 1 0 0 1 1 .....
    .................
   ``` 
1. Дано число n. Создайте следующую матрицу размера n на n: На главной диагонали матрицы чередуются 1 и 2. Дальше от каждой клетки главной диагонали направо и вниз расставляется то же числа, что и в самой этой клетке. Пример для аргумента (5):
```
    1 1 1 1 1
    1 2 2 2 2
    1 2 1 1 1
    1 2 1 2 2
    1 2 1 2 1
```
Здесь, если не можете справиться без цикла, сделайте один цикл. Но не больше!
Кстати, а какой определитель у этой матрицы? А почему?!

### Индексирование в Ocatave `octave-indexing`
В этих задачах тоже нельзя использовать циклы, если явно не сказано обратного.
1. Дана квадратная матрица четного размера. Поделите ее пополам по вертикали и горизонтали и верните матрицу, соответствующую верхнему левому квадрату.
1. Дана матрица с четным числом строк. Поменяйте местами верхнюю половину строк матрицы и нижнюю половину.
1. Дан вектор из целых чисел. Верните вектор, который содержит только те числа исходного вектора, которые делятся на 3.
1. Сделайте две функции. Первая `filter_multiples(a, k)` удаляет из вектора a все числа, которые строго больше k и делятся на k. Вторая `sieve()` делает следующее:
    ```
    function a = sieve(n)
      a = 1:n;
      i = 2;
      while i < length(a)
        a = filter_multiples(a, a(i));
        i++
      endwhile
    endfunction
    ```
    Объясните в комментариях, что и как делает функция sieve(n)
1. Дана матрица из двух столбцов. Каждая строка описывает человека: его рост в метрах и тип. В задаче есть пять типов: 1 - девочка, 2 - девушка, 3 - мальчик, 4 - мужчина, 5 - кот. Необходимо вернуть три матрицы-столбца из пяти элементов каждая.
Первая матрица содержит суммарный рост для каждого из пяти типов людей.
Вторая — средний рост для каждого из типов. При необходимости делить на 0 пусть ответом будет `NaN`.
Третья — средний рост, не учитывая тех, чей рост меньше 1 метра или больше 2 метров.
Не используйте цикл для перебора людей. Вы можете использовать цикл перебора типов от 1 до 5, но здорово, если сумеете придумать, как не использовать и его тоже.
1. Увеличьте все нечетные числа матрицы-строки в два раза.
    * А если это не матрица строка, а прямоугольная матрица? Будет работать ваше решение?

### Графика в Ocatave `octave-graphics`
1. Нарисуйте график функции \\(sin(x) + sin(3x)\\) в диапазоне от \\(-2\\pi\\) до \\(2\\pi\\). Функция должна не только нарисовать график, но и вернуть два значения: x с абсциссами и y с ординатами точек, это те же значения, которые вы передадите в функцию plot(x,y)
Нарисуйте график функции sin(x) + sin(2x) + sin(3x) + ... + sin(100x),  обойдитесь без циклов. Верните результат как в прошлой задаче.
Дана матрица A размера 2xN, каждый столбец - координаты точки на плоскости. (Все задачи могут быть решены без циклов, соответственно, решите из без циклов). В этой задаче функция не должна возвращать результат, она должна только рисовать одну картинку
Изобразите множество A
Изобразите центр масс множества A (одна точка, другой маркер, другой цвет)
Изобразите множество B, которое получается параллельным переносом множества A так, чтобы его центр масс перешел в 0. (Новый тип маркера, новый цвет). Напоминание: при параллельном переносе на вектор dx, dy координаты точки x, y заменяются на x + dx, y + dy.
Изобразите множество C: поворот множества A вокруг нуля на 10 градусов. (Новый тип маркера, новый цвет). Напоминание. Чтобы повернуть точку с координатами x, y на угол fi относительно нуля, нужно домножить вектор столбец [x;y] слева на матрицу [cos(fi) sin(fi); -sin(fi) cos(fi)]
Изобразите множество D: поворот множества А вокруг его центра масс на 10 градусов.
Нарисуйте 10 концентрических окружностей с радиусами, соответственно, 1, 2 … 10. Используйте для этого тот факт, что точки с координатами cos(phi), sin(phi) лежат на одной окружности радиуса 1, при phi меняющемся от 0 до 2pi.
Дана линейная матрица из трех чисел a, b, c. Кроме этого даны матрицы xrange=[xmin, xmax] и yrange=[ymin,ymax] Постройте график прямой ax + by + c = 0, нужно построить ту ее часть, которая содержится в прямоугольнике xmin <= x <= xmax и ymin < =y <= ymax. Учтите все варианты, включая то, что прямая может быть вертикальной.
Правильно было бы решать так. Нужно пересечь заданную прямую с каждой из четырех сторон прямоугольника. Стороны горизонтальны или вертикальны, поэтому вычислить пересечение с каждой конкретной стороной или проверить, что его нет, относительно несложно. В общей сложности получится два пересечения. Далее нужно нарисовать отрезок от первой точки пересечения до второй, для этого достаточно одного вызова функции plot().
Функция plot_lines(a, xrange, yrange). Дана матрица с прямыми как в задании 3 из блока octave-vectorization. Постройте на одном графике все эти прямые. Вызовите для этого в цикле функцию из предыдущей задачи.
Функция plot_lines_and_intersections(a, xrange, yrange). Дана матрица с прямыми как в задании 6. Воспользуйтесь предыдущей задачей 6 из задачей 5 из блока octave-vectorization, нарисуйте все прямые и все их точки пересечения.
