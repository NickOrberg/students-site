---
type: tasks
---
# Задания по пакету Octave

### Базовые задания `octave-1`

Загрузите в папку octave-1 три файла `task1.m`, `task2.m`, `task3.m`, которые мы делали на практике.

### Создание матриц `octave-matrices`

Создайте указанные матрицы. В этих задачах нельзя использовать циклы. И вы должны избежать ручного ввода элементов матрицы, вместо этого используйте возможности Octave по конструированию матриц. Т.е., например, если вас попросили создать матрицу 10 на 10, не перечисляейте в решении все 100 элементов этой матрицы. Т.е. представьте, что вас просят на самом деле создавать матрицы 1000 на 1000. Маленькие матрицы в условии нужны для того, чтобы вам было проще отладить свою программу, увидев матрицы на экране целиком.
1. Создайте матрицу 10 на 10, у которой все элементы нули, кроме первой строки, в которой все элементы единицы
1. Создайте матрицу 10 на 10, у которой в каждой клетке стоит 0 или 1 в шахматном порядке:
```
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    ...
```    
1. Матрица 9 на 9, вся первая строка состоит из единиц, вторая строка состоит из двоек, третья — из троек и т.д.
1. Создайте матрицу 10 на 10 с подряд идущими числами от 1 до 100
```
     1  2  3  4  5  6  7  8  9 10
    11 12 13 14 15 16 17 18 19 20
    21 22 23 24 25 26 27 28 29 30
    ...
   ``` 
1. "Таблица умножения". Матрица 9 на 9, где в каждой клетке стоит произведение номера столбца на номер строки:
```
     1  2  3  4  5  6  7  8  9
     2  4  6  8 10 12 14 16 18
     ...
   ```  
1. Даны числа n, a, b. Создайте матрицу размера n на n, у которой на главной диагонали стоят числа a, а строго над и под главной диагональю стоят числа b. Остальные числа матрицы — нули. Пример для аргументов (4, 1, 2):
```
    1 2 0 0
    2 1 2 0
    0 2 1 2
    0 0 2 1
   ``` 
1. Вспомните задачу 2. Там еще 1 и 0 в были в шахматном порядке. Создайте теперь матрицу 20 на 20, только теперь «клеточки» должны быть два на два:
```
    0 0 1 1 0 0 .....
    0 0 1 1 0 0 .....
    1 1 0 0 1 1 .....
    1 1 0 0 1 1 .....
    .................
   ``` 
1. Дано число n. Создайте следующую матрицу размера n на n: На главной диагонали матрицы чередуются 1 и 2. Дальше от каждой клетки главной диагонали направо и вниз расставляется то же числа, что и в самой этой клетке. Пример для аргумента (5):
```
    1 1 1 1 1
    1 2 2 2 2
    1 2 1 1 1
    1 2 1 2 2
    1 2 1 2 1
```
Здесь, если не можете справиться без цикла, сделайте один цикл. Но не больше!
Кстати, а какой определитель у этой матрицы? А почему?!

### Индексирование в Ocatave `octave-indexing`
В этих задачах тоже нельзя использовать циклы, если явно не сказано обратного.
1. Дана квадратная матрица четного размера. Поделите ее пополам по вертикали и горизонтали и верните матрицу, соответствующую верхнему левому квадрату.
1. Дана матрица с четным числом строк. Поменяйте местами верхнюю половину строк матрицы и нижнюю половину.
1. Дан вектор из целых чисел. Верните вектор, который содержит только те числа исходного вектора, которые делятся на 3.
1. Сделайте две функции. Первая `filter_multiples(a, k)` удаляет из вектора a все числа, которые строго больше k и делятся на k. Вторая `sieve()` делает следующее:
    ```
    function a = sieve(n)
      a = 1:n;
      i = 2;
      while i < length(a)
        a = filter_multiples(a, a(i));
        i++
      endwhile
    endfunction
    ```
    Объясните в комментариях, что и как делает функция sieve(n)
1. Дана матрица из двух столбцов. Каждая строка описывает человека: его рост в метрах и тип. В задаче есть пять типов: 1 - девочка, 2 - девушка, 3 - мальчик, 4 - мужчина, 5 - кот. Необходимо вернуть три матрицы-столбца из пяти элементов каждая.
Первая матрица содержит суммарный рост для каждого из пяти типов людей.
Вторая — средний рост для каждого из типов. При необходимости делить на 0 пусть ответом будет `NaN`.
Третья — средний рост, не учитывая тех, чей рост меньше 1 метра или больше 2 метров.
Не используйте цикл для перебора людей. Вы можете использовать цикл перебора типов от 1 до 5, но здорово, если сумеете придумать, как не использовать и его тоже.
1. Увеличьте все нечетные числа матрицы-строки в два раза.
    * А если это не матрица строка, а прямоугольная матрица? Будет работать ваше решение?
    
### Векторизация `octave-vectorization`

В этих задачах вообще нельзя использовать циклы

1. Дана матрица строка, например, `a = [1, 2, -2, 4]` и число `x`, например 1.
Строка `a` задает коэффициенты многочлена, начиная с младшего, т.е. она соответствует многочлену
\\(1 + 2x - 2x^2 + 4x^3\\). Посчитайте значение многочлена в точке `x`.
Для приведенного примера ответ будет 5. Т.е. необходимо написать выражение через `a` и `x`,
которое считает значение многочлена `a` в точке `x`.
__Замечание__: в Octave есть функция `polyval`, делающая аналогичные действия, но у нее иначе интерпретируются
аргументы. Не пользуйтесь этой функцией при решении задачи.
1. Дана матрица-столбец x. Создать квадратную матрицу такого же размера, которая в i-ой строке
и j-ом столбце содержит разность `x(i) – x(j)`.
1. Дана матрица, состоящая из трех столбцов. Предположим, что каждая строка задает прямую вида \\(ax + by + c = 0\\),
где столбцы — это, соответственно, числа `a`, `b`, `c`. Создайте матрицу, состоящую из двух столбцов с числами,
соответственно, `k` и `b`, которые описывает эти же прямые, только в виде \\(y = kx + b\\). Например, строка `[1 1 1]`
должна превратиться в строку `[-1 -1]`.
1. Функция `all2dets(x)`. Дана матрица `x` из двух столбцов. Создать квадратную матрицу,
размером в количество строчек исходной.
Элемент в i-ой строке j-ом столбце должен быть равен определителю матрицы `[x(i,:); x(j,:)]`, т.е. матрицы 2x2,
составленной из i-ой и j-ой строк исходной матрицы. Напомню, что определитель матрицы
\\(\\begin{pmatrix}a&b\\\\c&d\\end{pmatrix}\\)
равен \\(ad - bc\\).
1. Функция `all_lines_intersections(a)`. Дана матрица `а` из трех столбцов, описывающая набор прямых
(см. предыдущее задание). Если кратко сформулировать условие, то нобходимо пересечь каждую прямую с каждой.
Подробней так: каждое пересечение прямой из строки i с прямой из строки j дает две координаты пересечения x и y.
Функция должна вернуть две матрицы `x` и `y`. Первая содержит x координату этого пересечения в строчке i
и столбце j, вторая содержит, соответственно, y координату. Не обрабатывайте отдельно случаи параллельных прямых,
пусть для параллельных прямых получается произвольный ответ, скорее всего, у вас это будет NaN из-за деления 0 на 0.
Напомню формулу пересечения прямых \\(a_1x+b_1y+c_1\\) = 0 и \\(a_2x+b_2y+c_2 = 0\\):
    ```
    Δ = det([a1 b1; a2 b2])
    Δx = det([-c1 b1; -c2 b2])
    Δy = det([a1 -c1; a2 -c2])
    x = Δx / Δ
    y = Δy / Δ
    ```
Соответственно, пользуйтесь задачей 4 для решения.

### Графика в Ocatave `octave-graphics`
Не используйте при решении задач циклы, если не сказано обратного.

1. Нарисуйте график функции \\(\\sin(x) + \\sin(3x)\\) в диапазоне от \\(-2\\pi\\) до \\(2\\pi\\). Функция должна не только нарисовать график, но и вернуть два значения: `x` с абсциссами и `y` с ординатами точек, это те же значения, которые вы передадите в функцию plot(x,y).
1. Нарисуйте график функции \\(\\sin(x) + \\frac1{2}\\sin(2x) + \\frac1{3}\\sin(3x) + \\cdots + \\frac1{10}\\sin(10x)\\). Для решения задачи создайте матрицу, у которой в строках расположены значения каждого слагаемого по отдельности. Верните результат как в прошлой задаче.
1. Дана матрица A размера 2xN, каждый столбец — координаты точки на плоскости. В этой задаче функция не должна возвращать результат, она должна только рисовать одну картинку,
состояющую из следующих элементов:
    1. Изобразите множество A
    1. Изобразите центр масс множества A (одна точка, другой маркер, другой цвет)
    1. Изобразите множество B, которое получается параллельным переносом множества A так, чтобы его центр масс перешел в 0. (Новый тип маркера, новый цвет). Напоминание: при параллельном переносе на вектор \\((dx, dy)\\) координаты точки \\((x, y)\\) заменяются на \\((x + dx, y + dy)\\).
    1. Изобразите множество C: поворот множества A вокруг нуля на
    \\(5^\\circ\\). (Новый тип маркера, новый цвет).
    Напоминание. Чтобы повернуть точку с координатами \\((x, y)\\) на угол \\(\\varphi\\) относительно нуля,
    нужно домножить вектор столбец \\(\\begin{pmatrix}x\\\\y\\end{pmatrix}\\) слева на матрицу
    \\(\\begin{pmatrix}\\cos(\\varphi)&\\sin(\\varphi)\\\\-\\sin(\\varphi)&\\cos(\\varphi)\\end{pmatrix}\\).
    1. Изобразите множество D: поворот множества А вокруг его центра масс на \\(5^\\circ\\).
1. Нарисуйте 10 концентрических окружностей с радиусами, соответственно, 1, 2, …, 10.
Используйте для этого тот факт, что точки с координатами \\((\\cos(\\varphi), \\sin(\\varphi))\\) лежат на
одной окружности радиуса 1, при \\(\\varphi\\) меняющемся от 0 до \\(2\\pi\\).
1. Дана линейная матрица из трех чисел `a`, `b`, `c`. Кроме этого даны матрицы `xrange=[xmin, xmax]` и
`yrange=[ymin, ymax]`. Постройте график прямой \\(ax + by + c = 0\\), нужно построить ту ее часть,
которая содержится в прямоугольнике \\(x_{min} \\leq x \leq x_{max}\\) и \\(y_{min} \\leq y \\leq y_{max}\\).
Учтите все варианты, включая то, что прямая может быть вертикальной.
Удобней всего решать так. Нужно пересечь заданную прямую с каждой из четырех сторон прямоугольника.
Стороны горизонтальны или вертикальны, поэтому вычислить пересечение с каждой конкретной стороной или проверить,
что его нет, относительно несложно. В общей сложности получится два пересечения.
Далее нужно нарисовать отрезок от первой точки пересечения до второй, для этого достаточно одного вызова функции `plot()`.
1. Функция `plot_lines(a, xrange, yrange)`. Дана матрица с прямыми как в задании 3 из блока `octave-vectorization`.
Постройте на одном графике все эти прямые. Вызовите для этого в цикле функцию из предыдущей задачи.
1. Функция `plot_lines_and_intersections(a, xrange, yrange)`. Дана матрица с прямыми как в предыдущем задании.
Воспользуйтесь предыдущей задачей и задачей 5 из блока `octave-vectorization`, нарисуйте все прямые и все их
точки пересечения.
