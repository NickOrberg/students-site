---
type: tasks
---

# Основы программирования

## Задания

Задачи на сайте [repl.it](http://repl.it) для автоматической проверки:
[присоединиться к курсу](https://repl.it/classroom/invite/Y4lXO57)

### Типы и условные операторы
1. **Високосный год** Дан год, определить, високосный или нет.
1. **Коты** Дано целое число. Верните строку, в которой к этому числу приписано существительное "кот"
в правильной форме. Например, "1 кот", "2 кота", "5 котов".
1. **Квадратное уравнение** Даны коэффициенты квадратного уравнения, целые числа a, b, c: \\(ax^2+bx+c = 0\\) Решите квадратное уравнение.
Разберите все случаи, включая \\(a = 0\\). Верните ответ в виде одной из следующих строк: «решений нет», «одно решение x = ...»,
«два решения x1 = ..., x2 = ...» или «решений бесконечно много». Округлите ответы до двух знаков после запятой.
Если в уравнении два корня, сначала выведите меньший корень.
1. **Квадратный трехчлен** Даны три целых числа a, b, с, выведите многочлен ax^2+bx+с. Верните результат в виде строки.
Проделайте все традиционные упрощения, т.е. не умножайте на нули, единицы, не прибавляйте нули. Например,
    ```python
        poly(1,2,3) == "x^2+2x+3"
        poly(2,0,-1) == "2x^2-1"
        poly(0,0,0) = "0"
    ```
1. **Число в виде текста** Дано целое число от 1 до 999, верните его в виде текста. Убедитесь, что вы не выводите двух пробелов подряд,
и пробелов в конце.
    * **Длинное число в виде текста** Решите задачу, при условии, что дано число от 1 до 999_999_999.

### Строки
В Python есть циклы. Для следующих задач вам будет достаточно только одного вида цикла, а все разнообразие возможностей циклов мы обсудим позже: [краткая информация о циклах](loops.md)

В следующих задачах нужно вывести несколько строчек символов. Для каждой задачи создайте функцию, кторая возвращает один String, содержащий сразу несколько строк, в конце каждой строки нужно поместить символ перевода строки `\n`. Например, если в задаче сказано, нарисуйте квадратик 3 на 3 из символов x, ваша программа должна сделать
что-то наподобие следующего:
```python
def example():
    s = "xxx\n"
    s += "xxx\n"  # оператор += эквивалентен в данном случае s = s + "xxx\n"
    s += "xxx\n"
    return s
    
print(example())  # тестируем результат
```

В качестве дополнительного задания, попытайтесь в каждой задаче придумать короткое и красивое решение. Особенно это актуально в последних задачах. Красивое решение должно хорошо читаться и не иметь дублирований кода, т.е. вы должны избегать повторения
в коде одинаковых или очень похожих действий.

1. Дано n (как аргумент вашей функции). Нарисуйте квадратик из букв `x` размера \\(n\\times n\\).
1. Нарисуйте "треугольник". У него в первой строке одна буква `x`, во второй -- две, и т.д. до \\(n\\), которое дано в качестве аргумента.

        x
        xx
        xxx
        xxxx
        xxxxx
        
1. Аналогично предыдущему, но только треугольник нужно перевернуть:

        xxxxx
        xxxx
        xxx
        xx
        x
        
1. Аналогично предыдущему, но надо снова перевернуть треугольник. Пустое место заполните пробелами:

              x
             xx
            xxx
           xxxx
          xxxxx
          
1. Дано n, нарисуйте шахматную доску из 1 и 0 размера \\(n\\times n\\). Например, при n = 7:

        1010101
        0101010
        1010101
        0101010
        1010101
        0101010
        1010101
        
1. Даны n и k, нарисуйте шахматную доску размера \\(n\\times n\\) из 1 и 0 с клетками размера размера \\(k\\times k\\). Например,
при n = 4, k = 3:

        111000111000
        111000111000
        111000111000
        000111000111
        000111000111
        000111000111
        111000111000
        111000111000
        111000111000
        000111000111
        000111000111
        000111000111
        
1. Напечатайте на экране таблицу размера m на n, используя полный набор символов псевдографики. Это символы └, ├ и другие. Вводите эти символы с помощью \u нотации. Ниже перечислены все необходимые символы и соответствующие им коды. Не выводите лишние пробелы, на картинке они даны только для наглядности.
    ```
        ┌ ─ ┬ ─ ┐ \u250C \u2500 \u252C \u2500 \u2510

        │   │   │         3 раза \u2502

        ├ ─ ┼ ─ ┤ \u251C \u2500 \u253C \u2500 \u2524

        │   │   │         3 раза \u2502

        └ ─ ┴ ─ ┘ \u2514 \u2500 \u2534 \u2500 \u2518
    ```
    Например, для m = 2, n = 3 получится таблица
    ```
        ┌─┬─┬─┐
        │ │ │ │
        ├─┼─┼─┤
        │ │ │ │
        └─┴─┴─┘
    ```

### Операции со строками и другими последовательностями

Лекция: [Операции со строками, операции с последовательностями](http://nbviewer.jupyter.org/github/iposov/students-site/blob/master/18fall/programming_basics/python-strings-sequences.ipynb)

При решении следующих задач не пользуйтесь ничем, что мы еще не проходили. Например, мы еще не умеем еще полноценно пользоваться циклами, мы только можем перебирать натуральные числа. Старайтесь не пользоваться циклами там, где они не нужны.

1. Дана строка, проверьте, является ли она палиндромом. Т.е. верно ли, что если ее прочитать с конца в начало, то получится та же строка.
    * Добавьте в функцию второй логический параметр strict, если он False, то при проверке нужно игнорировать регистр букв и пробелы.
1. Дана строка, проверьте, верно ли, что в ней все символы идут парами одинаковых. Например, для строки `aaBBccDD55**` нужно вернуть `True`, а для строки `aaBBcC**hF` нужно вернуть `False`.
1. Дана строка, состоящая из букв (это можно не проверять в функции, вам это гарантируется). Проверьте, что регистр букв чередуется. Например, подходит строка `aBsTjU` и `aBa`, но не подходят `aBBa` и `FFFFa`.
1. Напишите функцию, которой дается строка. Она должна поменять местами все использования 0 на 1, а все использования 1 на 0. Например,
`abc01xyz000111` должно превратиться в `abc10xyz111000`.
    * Добавьте в функцию два параметра: символы для замены. Т.е. заменять можно не только 0 на 1 и наоборот, а любой символ на любой. На самом деле, решить нужно эту задачу. А вариант с 0 и 1 нужен только для тренировки.
    * Чтобы решить задачу, попробуйте разобраться либо в методе `replace` для строк. Либо в паре методов `translate` и `maketrans`. Второй вариант предпочтительней, но чуть сложнее, чтобы разобраться.
1. Кривая дракона. В функцию передается один аргумент, целое число \\(n\\ge0\\). Если передан 0, нужно вернуть строку `R`. Иначе нужно повторить \\(n\\) раз следующую операцию: допустим, на предыдущем шаге мы получили строку \\(S\\). Нужно к ней приписать букву `R`, а потом приписать снова \\(S\\), но, во-первых, прочитанную с конца, а, во-вторых, в которой буквы `R` заменены на буквы `L` и наоборот. Например, при \\(n=1\\) получается `RRL` как `R` + `R` + `L`, при \\(n=2\\) получается `RRLRRLL` = `RRL` + `R` + `RLL` и т.д.
    * В качесте необязательного дополнения: подключите библиотеку `turtle`, разберитесь в ней и заставьте черепаху двигаться по полученным в этой задаче правилам. Она идет на фиксированное расстояние, потом поворачивается направо или налево в зависимости от очередной буквы в строке, потом снова идет на такое же расстояние, и процесс продолжается.
1. Коды Грея, часть 1. Создайте функцию, в которую передается один аргумент, целое число \\(n\\ge0\\). Если передан 0, нужно вернуть список `[0]`. Иначе нужно повторить \\(n\\) раз следующую операцию: приписать список из предыдущего шага к самому себе, вставив в середине число с номером шага. На примере это выглядит так:
```
n = 0     [0]
n = 1     [0 1 0]
n = 2     [0 1 0 2 0 1 0]
n = 3     [0 1 0 2 0 1 0 3 0 1 0 2 0 1 0]
...
```
1. Коды Грея, часть 2. Создайте функцию, в которую передается один аргумент, целое число \\(n\\ge0\\). Нужно вызвать функцию из прошлой задачи с аргументом \\(n - 1\\) и запомнить полученный список в переменную `positions`. Дальше вы создаете список `gray` из \\(n\\) нулей и начинаете перебирать элементы `positions`. Каждый элемент `positions` говорит, по какому индексу в списке `gray` нужно заменять 0 на 1 или 1 на 0. Все полученные списки `gray` нужно собрать в один большой список и вернуть его. Например, при \\(n = 2\\) должен получиться результат:
```
[
    [0, 0, 0],
    [1, 0, 0],
    [1, 1, 0],
    [0, 1, 0],
    [0, 1, 1],
    [1, 1, 1],
    [1, 0, 1],
    [0, 0, 1]
]    
```

### Операции со списками, продолжение

Лекция [Продвинутые операции с последовательностями](http://nbviewer.jupyter.org/github/iposov/students-site/blob/master/18fall/programming_basics/advanced-seq-types.ipynb)
