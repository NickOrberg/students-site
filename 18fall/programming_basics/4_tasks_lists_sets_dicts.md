---
type: tasks
---
# Задачи: Списки, множества, словари

1. Множества
    1. Дана строка. Вернуть множество из всех его символов.
    1. Дана строка (предложение). Вернуть множество из всех его слов (слова — это последовательность из непробельных символов).
    1. Даны две строки (два предложения). Вернуть список слов, которые встречаются и в первом, и во втором предложении.
        * ищите совпадения слов, игнорируя регистр.
1. \[expr for x in list if condition\]
    1. Дан список чисел, верните новый список, где все элементы возведены в квадрат.
    1. Дан список чисел, верните новый список, в котором из исходного списка удалены все четные элементы.
    1. Дан список строк, верните новый список, в котором все строки превращены в целые числа (используйте функцию `int`), но нужно проигнорировать те строки, которые не являеются числами. Например, `['1', 'a', '42']` должно превратиться в `[1, 42]`. Используйте метод `isdigit()` для строк, чтобы проверить, что строка состоит только из цифр.
    1. Дан список, верните новый список, в котором каждый элемент повторен дважды. Например, `[1, 2, 'x']` -> `[1, 1, 2, 2, 'x', 'x']`
    1. Решето эратосфена (простой, но не самый эффективный способ).
        1. Напишите функцию, которая по числу $k$ и списку возвращает новый список, в котором удалены все элементы, делящиеся на $k$, и строго большие, чем $k$.
        1. Дано $n$. Создайте список `ints` чисел от 2 до $n$ (оберните range в list). Пока список не пуст, доставайте из него первый элемент $p$. Сохраните этот элемент в список `primes`. Вызывайте предыдущую функцию: `ints = filter_k(ints, p)`. Верните список `primes` и проверьте, что это получились простые числа.
    1. Дано число \\(n\\), создайте список из всех его положительных делителей. Для этого переберите все числа от 1 до \\(n\\).
         1. Эффективней перебирать числа от 1 до \\(\\sqrt{n}\\), при этом, если получился делитель \\(d\\), то \\(\\fraс{n}{d}\\) это тоже делитель. Найдите список всех делителей этим способом.
    1. Проверьте число на простоту
1. Проверка орфографии
    Загрузите файл со списком английских слов, но пока не трогайте его: [english_words.zip](https://github.com/dwyl/english-words/blob/master/words_alpha.zip?raw=true). А еще найдите (например, на сайте [lib.ru](http://lib.ru)) какой-нибудь длинный английский текст.
    1. Дано множество строк (орфографический словарь), это слова, которые мы будем считать орфографически правильными. Считаем, что эти слова все указаны в нижнем регистре. И дан список слов, которые надо проверить. Верните список слов, которые не нашлись в словаре. Например, `orpho_check({'a', 'b', 'c'}, ['a', 'bb', 'c', 'cc', 'bb']` должно вернуть `['bb', 'cc', 'bb]`.
    1. Дана строка, это текст на английском. Верните список слов в этом тексте. Используйте `split` без аргументов, чтобы разбить текст на слова по пробелам, переводам строк и другим пробельным символам, а потом используйте `strip`, чтобы удалить все знаки препинания из конца и начала слов. Эту функцию назовите `tokenize`.
    1. Дано имя файла, это файл с орфографическим словарем. Верните список слов в этом файле. Каждое слово находится в отдельной строке. Убедитесь, что в списке слов у слов нет на конце символов переводра строк, и что все слова приведены к нижнему регистру. Назовите функцию `read_orpho_dict`.
    1. Дано имя файла, прочитайте из него весь текст и верните список слов этого текста. Пользуйтесь уже реализованными функциями. Эту функцию назовите `tokenize_file`.
    1. Дано три имени файла. Имя файла со словарем, имя файла с текстом, имя файла для вывода результата. Прочитайте из первого файла словрь, из второго — слова. Распечатайте на экране все слова, которые не нашлись в орфографическом словаре, и выведите их же в файл с результатом. Т.е. на экране и в файле с результатом должен быть один и тот же список слов.

        *Теперь будем пытаться исправлять ошибки*
    1. Дано слово, верните множество слов, которые получаются из исходного удалением одной из букв. Например, слово `ccat` должно превратиться в множество `{'cat', 'cct', 'cca'}`.
    1. Продолжение следует
