---
type: tasks
---

# R basics.

Please, create functions for each of the tasks. Functions shouls be named as task names, usually, as `task1`, `task2`, etc.
Here are some function examples:

```R
fun1 <- function(x, y) { # here are arguments in the brackets
  x + y # the result of the function is its last expression
}

# let's now call the function
fun1(10, 20) # this is 30

# another example
fun2 <- function(n) {
   c(1:n, n:1)
}

# let's test the function
fun2(5) # this is a vector 1, 2, 3, 4, 5, 5, 4, 3, 2, 1

fun3 <- function() {
    x <- rbinom(20, size=1, prob=0.5)  # toss a coin 20 times
    mean(x) # this is the result of a function, because this is the last expression
}

fun3() # the result is always different, but it should be about 0.5


```

1. **task1** Read help about the `rep` function (type `help(rep)`). Then use it to produce a vector of repeating numbers 1, 2, and 3: \\(1, 2, 3, 1, 2, 3, 1, 2, 3, \\ldots\\). The length of the vector should be 40.
    1. **task1a**  You are given integers `n` and `size`, create a vector of repeating numbers from `1` to `n` of size `size`, for example, `task1a(3, 10)` should return `c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1)`.
    
...translating
    
1. Даны целые числа `n` и `size`. С помощью функции `sample` сгенерируйте вектор из случайных целых чисел от `1` до `n` и верните его.
   С помощью функций `table` и `print` выведите на экран, сколько раз сгенирировалась какое число.
1. Дан вектор и число `k`. Удалите из вектора все вхождения этого числа.
1. Дано целое число `steps`, сгенерируйте вектор длины `steps` состоящий из чисел 1 и -1. Верните сумму чисел.
1. Смешанное распределение. Дано число `size`. Сгенерируйте вектор размера `size` по следующему алгоритму: чтобы получить очередное число,
   вектора сначала бросается монетка, в одном случае нужно сгенерировать число из распределения \\(N(0, 1)\\). Во втором случае из
   экспоненциального распределения с \\(\\lambda=1\\)
1. Сгенерируйте числовые вектора размера 1000, они указаны в конце задания. Для каждого вектора с помощью t-теста проверьте,
   верно ли, что матожидание равно нулю. Используйте функцию `t.test`. Потом сравните с помощью двухвыборочного t-теста
   (это та же самая функция t.test) каждую пару векторов и проверьте верно ли, что матожидания этих векторов совпадают.
   Функция ничего не должна возвращать, но должна печатать информацию на экране с помощью `print`.
   Разберитесь с информацией, которую выводит функция t.test, т.е. поймите всё, что она выводит.
   Не забудьте посмотреть помощь по этой функции, чтобы правильно выбрать набор аргументов.
   Необязательное задание, попробуйте разобраться, как в программе извлечь результат вызова t.test и автоматически проверить,
   попадает ли выборочное матожидание в доверительный интервал, т.е. можно ли принять гипотезу о равенстве матожиданий.
     * x = равномерно распределенные числа в отрезке от -1 до 1
     * y = нормально распределенные числа со средним 0 и стандартным отклонением 1
     * z = нормально распределенные числа со средним 0 и стандартным отклонением 10
     * t = нормально распределенные числа со средним 0.01 и стандартным отклонением 1
1. А теперь случайное блуждание на плоскости. Дано целое число steps. Сгенерируйте матрицу размера 2 на steps.
   Каждый столбик может быть одним из четырех вариантов: (1 0), (-1 0), (0 1), (0 -1). Теперь получите сумму чисел в первой
   строке, и сумму чисел во второй строке. Это координаты того, куда приблуждало блуждание. Верните вектор из двух этих чисел
1. Дано целое число n, запустите предыдущую задачу n раз, получите n точек и изобразите их на графике.
