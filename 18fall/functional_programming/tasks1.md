---
type: tasks
---

# Задачи

## Вводные

1. Напишите факториал с хвостовой рекурсией
1. Функция `sum1` складывает элементы списка.
    1. Сделайте вариант с хвостовой рекурсией
1. `last1` возвращает последний элемент списка
1. `conc1` конкатенация списков
1. `push` дописать элемент в конец списка
1. `repeat :: Int -> Char -> [Char]` повторить элемент указанное число раз
1. `get1` получить элемент списка по его индексу
1. `rev` перевернуть список

## Теория чисел

Пользуйтесь функциями обработки списков: `map`, `filter` и т.п.

1. Дано число, вывести список всех его положительных делителей.
1. Дано число, проверить его на простоту.   
   Воспользуйтесь предыдущей задачей, но не перебирайте список делителей полностью,
   проверьте только, какой делитель идёт после единицы.
1. Дано число, проверить, совершенное ли это число. Другими словами, верно ли что число
   равно сумме своих делителей, не считая себя. Например, 6 = 1 + 2 + 3.
1. Найдите все совершенные числа от 1 до миллиона
1. Решето эратосфена. Дано n, найдите все простые числа от 1 до n.
1. Простые близнецы. Дано n, найдите все пары простых чисел от 1 до n, отличающихся на 2.

## Операции на списках

### `foldl` и `foldr`

Решите каждую задачу с помощью одной из функций: `foldl` или `foldr`, определите сами, с помощью какой функции решение будет проще и естественней. После этого попробуйте решить с помощью второй функции.

1. Посчитайте количество элементов в списке
2. Переверните список
3. Припишите один список к другому (операция `++`)
4. Реализуйте функцию `filter`
5. Реализуйте функцию `map`
6. Реализуйте функцию `concatMap`. Она имеет тип: `(a -> [b]) -> [a] -> [b]` и делает следующее: `concatMap f l` применяет функцию `f` к каждому элементу списка `l` и получает списки. Все полученные списки объединяются в один.
7. Реализуйте `foldl` через `foldr`. И потом наоборот. (Подсказка: переворачивание списка мы делали через foldLeft, поэтому его можно использовать во втором случае)
1. (**NEW**) Напишите функцию `minmax`, которая возвращает минимальный и максимальный элемент списка в виде Tuple.

### `concatMap`

Следуюшие задачи нужно решить с помощью встроенной функции `concatMap`

1. Опять реализуйте `filter`
2. Реализуйте `map`
3. Дан список, повторите каждый его элемент два раза.

### `zip`, `zipWith` и `unzip`

Используйте функции zip, zipWith, unzip.

1. Реализуйте функцию zipWithIndex: к каждому элементу списка "припишите" его индекс. Т.е. каждый элемент списка должен превратиться в тьюпл, где вначале идет индекс элемента, а потом сам элемент. Начинайте считать элементы с нуля.
2. Сложите каждый элемент списка `[Int]` с его индексом.
3. Дан список `[Int]`, верните список, в котором все четные по счету элементы заменены на ноль
4. Дан список, удалите из него все элементы с четным индексом.
5. Дан список двузначных чисел. Верните тьюпл из двух списков: первые цифры чисел и вторые цифры чисел. Например, `[10, 44, 31]` превращается в `([1, 4, 3], [0, 4, 1])`.

## Несколько задач на алгоритмы

1. Алгоритм быстрого возведения в степень. Положим, нам нужно вычислить \\(x^n\\). Запишем следующее равенство:
\\(Answer = a^b \\cdot c\\). Оно верное, если \\(a = x\\), \\(b = n\\), \\(с = 1\\).
Теперь выполняем следующие шаги:
    * Если \\(b\\) четно, то заменяем \\(a \\rightarrow a^2\\), а \\(b \\rightarrow b/2\\). Теперь \\(Answer = (a^2)^{b/2}\\cdot c\\)
    * Если \\(b\\) нечетно, то заменяем \\(b \\rightarrow b-1\\), \\(с \\rightarrow c\\cdot a\\). Теперь \\(Answer = a^{b-1} \\cdot (a \\cdot c)\\)

    Когда \\(b\\) станет равно нулю, мы получим \\(Answer = a^0 \cdot c\\), т.е. ответ это \\(c\\).
    Реализуйте этот алгоритм функционально, с хвостовой рекурсией

1. Быстрая сортировка
    1. Напишите функцию, которая по списку и заданному числу возвращает три списка в виде Tuple: все элементы, меньшие `v`; все элементы, равные `v`; все элементы, большие `v`.
    1.  Напишите функцию, которая сортирует массив рекурсивно: Вызывает функцию из предыдущего пункта для первого элемента массива. Рекурсивно сортирует первый и третий списки, соединяет их опять в один список.
    
1. Сортировка слиянием.
    1. Напишите функцию, которая делит один список на два одинаковой длины. Или почти одинаковой, если длина нечетна. Просмотртие список функций по работе со списком из стандартной библиотеки, чтобы найти какую-нибудь функцию, которая в этом поможет.
    1. Напишите функцию, которая сливает два отсортированных списка в один отсортированный. Сделайте это рекурсивно, откусывая по одному элементу с начала каждого из списков.
    1. Теперь сама сортировка. Разделите заданный список на два равной длины. Рекурсивно сортируйте оба эти списка, потом слейте их вместе
    
## Алгебраические типы данных

Не забывайте писать в конце определений типов `deriving Show`, чтобы значения ваших типов можно было распечатывать.

1. Тип данных "Точка на плоскости".
    1. Создайте свой собственный тип данных Point (точка на плоскости) У каждой точки есть две `Int` координаты.
    1. Реализуйте функцию vectorSum поэлементного сложения точек
1. Тип данных "Фигура"    
    1. Создайте тип данных Figure, значениями этого типа могут быть круги, для которых известен радиус. Прямоугольник, у которого известно две стороны. Равносторонний треугольник, у которого тоже известна одна сторона.
    1. Реализуйте функцию `area :: Figure -> Double`, которая вычисляет площадь фигуры
1. На лекции мы самостоятельно ввели тип "список". Реализуйте для такого списка операции:
    1. Сумма всех элементов списка
    1. Переворачивание списка

## Операции с типом "Двоичное дерево"

Заведем тип "двоичное дерево"

        data Tree = Nil | Tree Int Tree Tree

Т.е. каждое дерево может быть либо пустым, либо быть узлом с целым значением и двумя деревьями, левым и правым. См. пример с лекции, там заведено похожее дерево.

Введем определения:

* Дерево поиска - это такое двоичное дерево, в котором элемент в каждой вершине строго больше всех элементов в левом поддереве и строго меньше всех элементов в правом поддереве.
* Куча - это такое двоичное дерево, в котором элемент в вершине строго больше всех элементов в левом и правом поддереве.

1. Заведите тип `Tree'`, параметризованный другим типом, чтобы дерево могло содержать не только Int значения.
1. Напишите функцию `sumTree :: Tree -> Int`, которая складывает все значения в дереве.
1. Создайте функцию линеаризации дерева, т.е. превращения дерева в список: пустое дерево превращается в пустой список. У непустого дерева сначала линеаризуйтся левое поддерево, потом в полученный список добавляется значение из корня дерева, потом в полученный список добавляются значения из линеаризованного правого поддерева.
    * Реализуйте эту же функцию для типа `Tree' a`
1. Создайте функцию добавления элемента в **дерево поиска**. Дано дерево поиска и новый Int элемент. Необходимо вернуть новое дерево, в которое этот элемент добавлен. Если такой элемент уже был, то вернуться должно незимененное дерево.
1. Дан список. Добавьте все его элементы по очереди в пустое дерево поиска, потом линеаризуйте дерево. Эта последовательность действий должна возвращать отсортированный список.
1. Создайте функцию удаления вершины из **кучи**. Дана куча, верните ее корневой элемент и новую кучу, без этого корневого элемента. Верните два значения в виде Tuple.
1. Дана куча. Удаляйте корни из кучи, собирайте их в список, пока куча не станет пустой. Верните полученный список.
1. (\*) Дано двоичное дерево, проверьте, является ли оно деревом поиска. Вам придется для каждого дерева не только вычислять, дерево ли это поиска, а еще искать максимальный и минимальный элемент.
1. (\*) Реализуйте функцию сворачивания дерева аналогично fold-функциям для списков. Посчитайте сумму всех элементов дерева с помощью этой функции.
