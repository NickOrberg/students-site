---
type: tasks
---

# Задачи

## Вводные

1. Напишите факториал с хвостовой рекурсией
1. Функция `sum1` складывает элементы списка.
    1. Сделайте вариант с хвостовой рекурсией
1. `last1` возвращает последний элемент списка
1. `conc1` конкатенация списков
1. `push` дописать элемент в конец списка
1. `repeat :: Int -> Char -> [Char]` повторить элемент указанное число раз
1. `get1` получить элемент списка по его индексу
1. `rev` перевернуть список

## Теория чисел

Пользуйтесь функциями обработки списков: `map`, `filter` и т.п.

1. Дано число, вывести список всех его положительных делителей.
1. Дано число, проверить его на простоту.   
   Воспользуйтесь предыдущей задачей, но не перебирайте список делителей полностью,
   проверьте только, какой делитель идёт после единицы.
1. Дано число, проверить, совершенное ли это число. Другими словами, верно ли что число
   равно сумме своих делителей, не считая себя. Например, 6 = 1 + 2 + 3.
1. Найдите все совершенные числа от 1 до миллиона
1. Решето эратосфена. Дано n, найдите все простые числа от 1 до n.
1. Простые близнецы. Дано n, найдите все пары простых чисел от 1 до n, отличающихся на 2.

## Операции на списках

### `foldl` и `foldr`

Решите каждую задачу с помощью одной из функций: `foldl` или `foldr`, определите сами, с помощью какой функции решение будет проще и естественней. После этого попробуйте решить с помощью второй функции.

1. Посчитайте количество элементов в списке
2. Переверните список
3. Припишите один список к другому (операция `++`)
4. Реализуйте функцию `filter`
5. Реализуйте функцию `map`
6. Реализуйте функцию `concatMap`. Она имеет тип: `(a -> [b]) -> [a] -> [b]` и делает следующее: `concatMap f l` применяет функцию `f` к каждому элементу списка `l` и получает списки. Все полученные списки объединяются в один.
7. Реализуйте `foldl` через `foldr`. И потом наоборот. (Подсказка: переворачивание списка мы делали через foldLeft, поэтому его можно использовать во втором случае)

### `concatMap`

Следуюшие задачи нужно решить с помощью встроенной функции `concatMap`

1. Опять реализуйте `filter`
2. Реализуйте `map`
3. Дан список, повторите каждый его элемент два раза.

### `zip`, `zipWith` и `unzip`

Используйте функции zip, zipWith, unzip.

1. Реализуйте функцию zipWithIndex: к каждому элементу списка "припишите" его индекс. Т.е. каждый элемент списка должен превратиться в тьюпл, где вначале идет индекс элемента, а потом сам элемент. Начинайте считать элементы с нуля.
2. Добавьте к каждому элементу списка `[Int]` его индекс.
3. Дан список `[Int]`, верните список, в котором все четные по счету элементы заменены на ноль
4. Дан список, удалите из него все элементы с четным индексом.
5. Дан список двузначных чисел. Верните тьюпл из двух списков: первые цифры чисел и вторые цифры чисел. Например, `[10, 44, 31]` превращается в `([1, 4, 3], [0, 4, 1])`.

