---
type: tasks
---

# Практические Задания

## Требования к оформлению заданий
В каждом блоке заданий указано название каталога, в который надо складывать решения. Названия заданий должны
быть `taskX.m`, где вместо `X` вы подставляете номер задачи. Например, `task1.m`, `task2.m` и т.п.
Изредка в самой задаче указано другое название функции, тогда вы должны использовать предложенное название.

В каждом блоке дополнительно указана дата дедлайна. После момента дедлайна я собираю все задачи у всех студентов.
Если у вас есть уважительная причина, почему вы не смогли сдать задания вовремя,
напишите мне письмо.

В решениях вы можете использовать только следующие
оператры, конструкции и приемы:

* Создание и комбинирование матриц с помощью квадратных скобок:
`[1, 2, 3]`;
* Оператор диапазона: `1:10` или `100:10:200`;
* Функции `ones`, `zeros`, `eye`;
* Арифметические операции над матрицами: сложения, вычитания,
умножения, деления; операции могут быть поэлементными (`.*`, `./`)или
матричными (`*`, `/`);
* Все виды индексирования;
* Расширение диапазона;

## Создание матриц `octave-matrices` ___понедельник 7 октября 23:59___

Создайте указанные матрицы. Пользуйтесь только теми возможностями, которые
указаны в лекциях на этом сайте. Избегайте констант в коде, это значит, что
ваша программа должна легко изменяться, если я попрошу создать матрицу другого
размера. 
 
1. Создайте матрицу 10 на 10, у которой все элементы нули, кроме первой строки, в которой все элементы единицы
1. Создайте матрицу размера 5 на 5, состоящую из чисел 5.
1. Создайте матрицу

    $  \\begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3
        \\end{pmatrix} $
 
1. Создайте матрицу 10 на 10, у которой в каждой клетке стоит 0 или 1 в шахматном порядке:
```
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    ...
```    
1. Матрица 9 на 9, вся первая строка состоит из единиц, вторая строка состоит из двоек, третья — из троек и т.д.
1. Создайте матрицу 10 на 10 с подряд идущими числами от 1 до 100
```
     1  2  3  4  5  6  7  8  9 10
    11 12 13 14 15 16 17 18 19 20
    21 22 23 24 25 26 27 28 29 30
    ...
   ``` 
1. "Таблица умножения". Матрица 9 на 9, где в каждой клетке стоит произведение номера столбца на номер строки:
```
     1  2  3  4  5  6  7  8  9
     2  4  6  8 10 12 14 16 18
     ...
   ```  
1. Даны числа n, a, b. Создайте матрицу размера n на n, у которой на главной диагонали стоят числа a, а строго над и под главной диагональю стоят числа b. Остальные числа матрицы — нули. Пример для аргументов (4, 1, 2):
```
    1 2 0 0
    2 1 2 0
    0 2 1 2
    0 0 2 1
   ``` 
1. Вспомните задачу 2. Там 1 и 0 были в шахматном порядке. Создайте теперь матрицу 20 на 20, только теперь «клеточки» должны быть два на два:
```
    0 0 1 1 0 0 .....
    0 0 1 1 0 0 .....
    1 1 0 0 1 1 .....
    1 1 0 0 1 1 .....
    .................
   ``` 
1. Дано число n. Создайте следующую матрицу размера n на n: На главной диагонали матрицы чередуются 1 и 2. Дальше от каждой клетки главной диагонали направо и вниз расставляется то же числа, что и в самой этой клетке. Пример для аргумента (5):
    ```
        1 1 1 1 1
        1 2 2 2 2
        1 2 1 1 1
        1 2 1 2 2
        1 2 1 2 1
    ```
    Здесь, если не можете справиться без цикла, разберитесь, как сделать цикл, и
    сделайте один цикл. Но не больше. Какой определитель у этой матрицы? Почему?
    
## Индексирование в Ocatave `octave-indexing` ___понедельник 14 октября 23:59___
В этих задачах тоже нельзя использовать циклы, если явно не сказано обратного. Вам может понадобиться функция
`mod(x, y)`, кторая считает остаток от деления `x` на `y`.
1. Дана квадратная матрица четного размера. Поделите ее пополам по вертикали и горизонтали и верните матрицу, соответствующую верхнему левому квадрату.
1. Дана матрица с четным числом строк. Поменяйте местами верхнюю половину строк матрицы и нижнюю половину.
1. Дан вектор из целых чисел. Верните вектор, который содержит только те числа исходного вектора, которые делятся на 3.
1. Дан вектор из целых чисел. Верните этот же вектор, но в котором все четные числа поделены на два. Будет ли работать
ваше решение, если исходная матрица не линейная, а прямоугольная?
1. `filter_multiples(a, k)` возвращет копию вектора `a`, в котором удалены все числа, строго большие $k$ и делящиеся на $k$.
1. `sieve(n)`. Решето Эратосфена. Вам понадобится цикл `while`, попробуйте найти информацию о его синтаксисе
самостоятельно.

    Требуется вернуть вектор из простых чисел от 1 до n. Для этого создайте вектор всех целых чисел от $2$ до $n$,
    С помощью предыдущей функции `filter_multiples` удалите сначла всё, что больше 2 и делится на 2. Потом всё, что
    больше 3 и делится на 3, потом все, что больше 5 (мы пропускаем 4, потому что оно уже было удалено на 
    первом шаге) и делится на 5, и т.д. За подробностями смотрите, что такое решето Эратосфена.
    
1. Дана матрица из двух столбцов. Каждая строка описывает зверя: его рост в метрах и вес в килограммах. 
Необходимо вернуть следующие данные:
    * суммарный рост зверей
    * средний рост зверей
    * средний рост зверей весом больше 100 килограмм.
    * матрицу из одного столбца с индексом массы тела (ИМТ) зверей. ИМТ равен весу, деленному на квадрат роста.
    * матрицу из двух столбцов со зверьми, у которых рост больше 10 метров, и вес больше 100 килограмм.
    
## Векторизация `octave-vectorization` ___четверг 24 октября 23:59___

В этих задачах вообще нельзя использовать циклы

1. Дана матрица строка, например, `a = [1, 2, -2, 4]` и число `x`, например 1.
Строка `a` задает коэффициенты многочлена, начиная с младшего, т.е. она соответствует многочлену
\\(1 + 2x - 2x^2 + 4x^3\\). Посчитайте значение многочлена в точке `x`.
Для приведенного примера ответ будет 5. Т.е. необходимо написать выражение через `a` и `x`,
которое считает значение многочлена `a` в точке `x`.
__Замечание__: в Octave есть функция `polyval`, делающая аналогичные действия, но у нее иначе интерпретируются
аргументы. Не пользуйтесь этой функцией при решении задачи.
1. Дана матрица-столбец x. Создать квадратную матрицу такого же размера, которая в i-ой строке
и j-ом столбце содержит разность `x(i) – x(j)`.
1. Дана матрица, состоящая из трех столбцов. Предположим, что каждая строка задает прямую вида \\(ax + by + c = 0\\),
где столбцы — это, соответственно, числа `a`, `b`, `c`. Создайте матрицу, состоящую из двух столбцов с числами,
соответственно, `k` и `b`, которые описывает эти же прямые, только в виде \\(y = kx + b\\). Например, строка `[1 1 1]`
должна превратиться в строку `[-1 -1]`.
1. Функция `all2dets(x)`. Дана матрица `x` из двух столбцов. Создать квадратную матрицу,
размером в количество строчек исходной.
Элемент в i-ой строке j-ом столбце должен быть равен определителю матрицы `[x(i,:); x(j,:)]`, т.е. матрицы 2x2,
составленной из i-ой и j-ой строк исходной матрицы. Напомню, что определитель матрицы
\\(\\begin{pmatrix}a&b\\\\c&d\\end{pmatrix}\\)
равен \\(ad - bc\\).
1. Функция `all_lines_intersections(a)`. Дана матрица `а` из трех столбцов, описывающая набор прямых
(см. предыдущее задание). Если кратко сформулировать условие, то нобходимо пересечь каждую прямую с каждой.
Подробней так: каждое пересечение прямой из строки i с прямой из строки j дает две координаты пересечения x и y.
Функция должна вернуть две матрицы `x` и `y`. Первая содержит x координату этого пересечения в строчке i
и столбце j, вторая содержит, соответственно, y координату. Не обрабатывайте отдельно случаи параллельных прямых,
пусть для параллельных прямых получается произвольный ответ, скорее всего, у вас это будет NaN из-за деления 0 на 0.
Напомню формулу пересечения прямых \\(a_1x+b_1y+c_1\\) = 0 и \\(a_2x+b_2y+c_2 = 0\\):
    ```
    Δ = det([a1 b1; a2 b2])
    Δx = det([-c1 b1; -c2 b2])
    Δy = det([a1 -c1; a2 -c2])
    x = Δx / Δ
    y = Δy / Δ
    ```
Соответственно, пользуйтесь задачей 4 для решения.

### Графика в Ocatave `octave-graphics` ___четверг 31 октября 23:59___
Не используйте при решении задач циклы, если не сказано обратного.

1. Нарисуйте график функции \\(\\sin(x) + \\sin(3x)\\) в диапазоне от \\(-2\\pi\\) до \\(2\\pi\\). Функция должна не только нарисовать график, но и вернуть два значения: `x` с абсциссами и `y` с ординатами точек, это те же значения, которые вы передадите в функцию plot(x,y).
1. Нарисуйте график функции \\(\\sin(x) + \\frac1{2}\\sin(2x) + \\frac1{3}\\sin(3x) + \\cdots + \\frac1{10}\\sin(10x)\\). Для решения задачи создайте матрицу, у которой в строках расположены значения каждого слагаемого по отдельности. Верните результат как в прошлой задаче.
1. Дана матрица A размера 2xN, каждый столбец — координаты точки на плоскости. В этой задаче функция не должна возвращать результат, она должна только рисовать одну картинку,
состояющую из следующих элементов:
    1. Изобразите множество A
    1. Изобразите центр масс множества A (одна точка, другой маркер, другой цвет)
    1. Изобразите множество B, которое получается параллельным переносом множества A так, чтобы его центр масс перешел в 0. (Новый тип маркера, новый цвет). Напоминание: при параллельном переносе на вектор \\((dx, dy)\\) координаты точки \\((x, y)\\) заменяются на \\((x + dx, y + dy)\\).
    1. Изобразите множество C: поворот множества A вокруг нуля на
    \\(5^\\circ\\). (Новый тип маркера, новый цвет).
    Напоминание. Чтобы повернуть точку с координатами \\((x, y)\\) на угол \\(\\varphi\\) относительно нуля,
    нужно домножить вектор столбец \\(\\begin{pmatrix}x\\\\y\\end{pmatrix}\\) слева на матрицу
    \\(\\begin{pmatrix}\\cos(\\varphi)&\\sin(\\varphi)\\\\-\\sin(\\varphi)&\\cos(\\varphi)\\end{pmatrix}\\).
    1. Изобразите множество D: поворот множества А вокруг его центра масс на \\(5^\\circ\\).
1. Нарисуйте 10 концентрических окружностей с радиусами, соответственно, 1, 2, …, 10.
Используйте для этого тот факт, что точки с координатами \\((\\cos(\\varphi), \\sin(\\varphi))\\) лежат на
одной окружности радиуса 1, при \\(\\varphi\\) меняющемся от 0 до \\(2\\pi\\).
1. (*сложно*) Дана линейная матрица из трех чисел `a`, `b`, `c`. Кроме этого даны матрицы `xrange=[xmin, xmax]` и
`yrange=[ymin, ymax]`. Постройте график прямой \\(ax + by + c = 0\\), нужно построить ту ее часть,
которая содержится в прямоугольнике \\(x_{min} \\leq x \leq x_{max}\\) и \\(y_{min} \\leq y \\leq y_{max}\\).
Учтите все варианты, включая то, что прямая может быть вертикальной.
Удобней всего решать так. Нужно пересечь заданную прямую с каждой из четырех сторон прямоугольника.
Стороны горизонтальны или вертикальны, поэтому вычислить пересечение с каждой конкретной стороной или проверить,
что его нет, относительно несложно. В общей сложности получится два пересечения.
Далее нужно нарисовать отрезок от первой точки пересечения до второй, для этого достаточно одного вызова функции `plot()`.
1. Функция `plot_intersections(a)`. Дана матрица с прямыми как в задании 3 из блока `octave-vectorization`.
Постройте на одном графике все пересечения этих прямых. Воспользуйтесь задачей 5 из блока `octave-vectorization`. 
1. Функция `plot_lines(a, xrange, yrange)`. Дана матрица с прямыми как в задании 3 из блока `octave-vectorization`.
Постройте на одном графике все эти прямые. Вызовите для этого в цикле функцию рисования прямой.
1. Функция `plot_lines_and_intersections_in_range(a, xrange, yrange)`. Дана матрица с прямыми как в предыдущем задании.
Воспользуйтесь предыдущей задачей и задачей 5 из блока `octave-vectorization`, нарисуйте все прямые и все их
точки пересечения.

### Решение уравнений `octave-equations` ___четверг 6 ноября 23:59___
1. Дано `n`, найти корни многочлена \\(x^n + x^{n - 1} + \\cdots + x + 1\\), т.е. многочлена степени \\(n\\), у которого все коэффициенты единицы. Верните корни в виде одной матрицы-строки. Найдите самостоятельно встроенную в Octave функцию, которая вычисляет корни многочлена.
    * Заставьте эту же функцию `task1` рисовать корни многочлена на плоскости. Так как корни многочлена комплексные, вам придется отдельно выделить их вещественную и мнимую часть. ___обязательно разберитесь, как выделить вещественную и мнимую части, не пользуйтесь версией функции `plot`, которая сама рисует комплексные числа — в этом случае решение получается слишком простым и скучным___.
1. Решите уравнение \\(x + \\sin(x)=1\\). Не забудьте реализовать функцию, которая вернет результат.
1. Решите систему уравнений \\(\begin{cases} x + \\sin(y) = 1 \\\\ y + \\cos(x) = 1 \end{cases}\\). Не забудьте реализовать функцию, которая вернет результат.
1. Дано вещественное число `a`. Решите уравнение \\(e^x - e^{-x}=a\\). Пусть функция возвращает четыре результата решения (не в виде матрицы, а именно в виде функции с четырьмя значениями):
    * Решение задачи с помощью `fsolve`. Здесь и в других пунктах проверяйте решение на числе «миллион».
    * Решение задачи с помощью `fzero`, здесь вам придется подумать, какой указать отрезок для поиска корня.
    * Решение задачи с помощью явной формулы. В этом уравнении можно явно выписать, чему равен `x`, подумайте, как это сделать.
    * Разность между решениями в виде явной формулы и с помощью `fsolve`.
1. Круг задается матрицей из трех чисел: `[x, y, r]` — координаты центра и радиус. Даны два круга. Нужно определить их точки пересечения. Для этого составьте систему из двух уравнений, описывающих круги, и используйте функцию `fsolve` для решения системы. Функция должна вернуть матрицу из двух строчек, в которой точки пересечения расположены в столбцах. Кроме этого, функция должна нарисовать оба круга и обозначить особым маркером точки пересечения.
Не пытайтесь вычислять точки пересечений явно, самостоятельно решая систему или делая геометрические построения.
    * Для начала найдите хотя бы одну точку пересечения.
    * А потом найдите обе точки. Вам придется проделать геометрические вычисления, чтобы определить две начальных точки для двух вызовов `fsolve`.
1. `domino.m`. Доминошки Основано на [http://www.math.cornell.edu/~levine/18.312/alg-comb-lecture-18.pdf](http://www.math.cornell.edu/~levine/18.312/alg-comb-lecture-18.pdf)
 
    Даны натуральные числа $m$ и $n$, это размеры клетчатого прямоугольника. В нём $m\times n$ клеточек, они пронумерованы от $1$ до $m\cdot n$. Составьте матрицу $A$ размера
    $m\cdot n\times m\cdot n$, в которой в которой в ячейке i,j находится:
        
    * 1, если клетки $i$ и $j$ - это две соседние по горизонтали клетки
    * мнимая единица, если клетки $i$ и $j$ - это две соседние по вертикали клетки
    * 0 иначе
    
    Посчитайте определитель матрицы $A$ и возьмите корень.
    Вы получите количество способов разбить прямоугольник m на n на доминошки.
1. Задача о клеточной функции (наполняется)

### Дифференциальные уравнения `octave-ode` ___четверг 14 ноября 23:59___ 

1. Решите неоднородное линейное дифференциальное уравнение с постоянными коэффициентами: \\(y' + 2y = x + \\frac12, y(0) = 1\\). Получите решение для `x = linspace(0, 1, 100)`. Функция должна вернуть три результата, строчку `x`, строчку значений функции `y1` и строчку значений функции `y2`:
    * `y1` получается решением уравнения с помощью функции `lsode`.
    * `y2` получается решением уравнения вручную. Вспомните, как решаются такие уравнения, получите решение в виде явной формулы.

    Постройте оба графика в одном окне, убедитесь, что они совпадают.
1. Решите уравнение \\(y''(x) + y(x) * (cos(x) + 1) = 0, y(0)=-1, y'(0)=1\\) на отрезке \\(0\leq x \\leq 10\\), постройте график решения, функция не должна ничего возвращать.

    * Создайте функцию `task2a` для решения того же уравнения,
     но в ней можно задавать начальные значения. В ней должно быть три параметра:
      координаты `x` значение для `y(0)` и для `y'(0)`. Сделайте функцию `task2b`
      для тестирования функции `task2a`, внутри должен быть следующий код:
    
               x = linspace(0, 10, 1000);
               plot(x, task2a(x, -1, 1));
               hold on
               plot(x, task2a(x, 0, 1));
               plot(x, task2a(x, 1, 1));
               plot(x, task2a(x, -1, 0));
               plot(x, task2a(x, 0, 0));
               plot(x, task2a(x, 1, 0));
               plot(x, task2a(x, -1, -1));
               plot(x, task2a(x, 0, -1));
               plot(x, task2a(x, 1, -1));

1. [Система Хищник-Жертва](http://goo.gl/sIsk5u).
Изучите статью по ссылке, в ней описывается система дифференциальных уравнений, моделирующая изменения популяций лис и кроликов, когда они живут вместе и едят друг друга. Создайте функцию, которая на вход получается параметры системы (альфа, бета, гамма, дельта), и рисует графики нескольких решений уравнений, соответствующих начальным данным, вокруг точки равновесия \\((\\overline{x}, \\overline{y})\\). Для этого возьмите начальные данные вида \\(x(0) = \\overline{x}, y(0) = \\overline{y} + ks\\). Здесь \\(k\\) — это целое число от 0 до 5, \\(s\\) - это величина, которая указывается еще одним (пятым) аргументом функции, получается, что на одном графике необходимо нарисовать шесть кривых для каждого значения \\(k\\). Функция должна только рисовать график в координатах x и y (не используйте координату t при рисовании), и ничего не должна возвращать. Убедитесь, что вы понимаете кривые, изображенные на графике.

### Задача о поиске кластеров методом k-средних `octave-k-means` ___четверг 20 ноября 23:59___
Эта задача на отдельной странице: [Метод k-средних](octave-k-means.md)
