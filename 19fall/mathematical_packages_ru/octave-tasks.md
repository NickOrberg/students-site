---
type: tasks
---

# Практические Задания

## Требования к оформлению заданий
В каждом блоке заданий указано название каталога, в который надо складывать решения. Названия заданий должны
быть `taskX.m`, где вместо `X` вы подставляете номер задачи. Например, `task1.m`, `task2.m` и т.п.
Изредка в самой задаче указано другое название функции, тогда вы должны использовать предложенное название.

В каждом блоке дополнительно указана дата дедлайна. После момента дедлайна я собираю все задачи у всех студентов.
Если у вас есть уважительная причина, почему вы не смогли сдать задания вовремя,
напишите мне письмо.

В решениях вы можете использовать только следующие
оператры, конструкции и приемы:

* Создание и комбинирование матриц с помощью квадратных скобок:
`[1, 2, 3]`;
* Оператор диапазона: `1:10` или `100:10:200`;
* Функции `ones`, `zeros`, `eye`;
* Арифметические операции над матрицами: сложения, вычитания,
умножения, деления; операции могут быть поэлементными (`.*`, `./`)или
матричными (`*`, `/`);
* Все виды индексирования;
* Расширение диапазона;

## Создание матриц `octave-matrices` ___понедельник 7 октября 23:59___

Создайте указанные матрицы. Пользуйтесь только теми возможностями, которые
указаны в лекциях на этом сайте. Избегайте констант в коде, это значит, что
ваша программа должна легко изменяться, если я попрошу создать матрицу другого
размера. 
 
1. Создайте матрицу 10 на 10, у которой все элементы нули, кроме первой строки, в которой все элементы единицы
1. Создайте матрицу размера 5 на 5, состоящую из чисел 5.
1. Создайте матрицу

    $  \\begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\\\ 
        2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3
        \\end{pmatrix} $
 
1. Создайте матрицу 10 на 10, у которой в каждой клетке стоит 0 или 1 в шахматном порядке:
```
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    0 1 0 1 0 1 0 1 0 1
    1 0 1 0 1 0 1 0 1 0
    ...
```    
1. Матрица 9 на 9, вся первая строка состоит из единиц, вторая строка состоит из двоек, третья — из троек и т.д.
1. Создайте матрицу 10 на 10 с подряд идущими числами от 1 до 100
```
     1  2  3  4  5  6  7  8  9 10
    11 12 13 14 15 16 17 18 19 20
    21 22 23 24 25 26 27 28 29 30
    ...
   ``` 
1. "Таблица умножения". Матрица 9 на 9, где в каждой клетке стоит произведение номера столбца на номер строки:
```
     1  2  3  4  5  6  7  8  9
     2  4  6  8 10 12 14 16 18
     ...
   ```  
1. Даны числа n, a, b. Создайте матрицу размера n на n, у которой на главной диагонали стоят числа a, а строго над и под главной диагональю стоят числа b. Остальные числа матрицы — нули. Пример для аргументов (4, 1, 2):
```
    1 2 0 0
    2 1 2 0
    0 2 1 2
    0 0 2 1
   ``` 
1. Вспомните задачу 2. Там 1 и 0 были в шахматном порядке. Создайте теперь матрицу 20 на 20, только теперь «клеточки» должны быть два на два:
```
    0 0 1 1 0 0 .....
    0 0 1 1 0 0 .....
    1 1 0 0 1 1 .....
    1 1 0 0 1 1 .....
    .................
   ``` 
1. Дано число n. Создайте следующую матрицу размера n на n: На главной диагонали матрицы чередуются 1 и 2. Дальше от каждой клетки главной диагонали направо и вниз расставляется то же числа, что и в самой этой клетке. Пример для аргумента (5):
    ```
        1 1 1 1 1
        1 2 2 2 2
        1 2 1 1 1
        1 2 1 2 2
        1 2 1 2 1
    ```
    Здесь, если не можете справиться без цикла, разберитесь, как сделать цикл, и
    сделайте один цикл. Но не больше. Какой определитель у этой матрицы? Почему?
    
## Индексирование в Ocatave `octave-indexing` ___понедельник 14 октября 23:59___
В этих задачах тоже нельзя использовать циклы, если явно не сказано обратного. Вам может понадобиться функция
`mod(x, y)`, кторая считает остаток от деления `x` на `y`.
1. Дана квадратная матрица четного размера. Поделите ее пополам по вертикали и горизонтали и верните матрицу, соответствующую верхнему левому квадрату.
1. Дана матрица с четным числом строк. Поменяйте местами верхнюю половину строк матрицы и нижнюю половину.
1. Дан вектор из целых чисел. Верните вектор, который содержит только те числа исходного вектора, которые делятся на 3.
1. Дан вектор из целых чисел. Верните этот же вектор, но в котором все четные числа поделены на два. Будет ли работать
ваше решение, если исходная матрица не линейная, а прямоугольная?
1. `filter_multiples(a, k)` возвращет копию вектора `a`, в котором удалены все числа, строго большие $k$ и делящиеся на $k$.
1. `sieve(n)`. Решето Эратосфена. Вам понадобится цикл `while`, попробуйте найти информацию о его синтаксисе
самостоятельно.

    Требуется вернуть вектор из простых чисел от 1 до n. Для этого создайте вектор всех целых чисел от $2$ до $n$,
    С помощью предыдущей функции `filter_multiples` удалите сначла всё, что больше 2 и делится на 2. Потом всё, что
    больше 3 и делится на 3, потом все, что больше 5 (мы пропускаем 4, потому что оно уже было удалено на 
    первом шаге) и делится на 5, и т.д. За подробностями смотрите, что такое решето Эратосфена.
    
1. Дана матрица из двух столбцов. Каждая строка описывает зверя: его рост в метрах и вес в килограммах. 
Необходимо вернуть следующие данные:
    * суммарный рост зверей
    * средний рост зверей
    * средний рост зверей весом больше 100 килограмм.
    * матрицу из одного столбца с индексом массы тела (ИМТ) зверей. ИМТ равен весу, деленному на квадрат роста.
    * матрицу из двух столбцов со зверьми, у которых рост больше 10 метров, и вес больше 100 килограмм.
    
## Векторизация `octave-vectorization` ___понедельник 21 октября 23:59___

В этих задачах вообще нельзя использовать циклы

1. Дана матрица строка, например, `a = [1, 2, -2, 4]` и число `x`, например 1.
Строка `a` задает коэффициенты многочлена, начиная с младшего, т.е. она соответствует многочлену
\\(1 + 2x - 2x^2 + 4x^3\\). Посчитайте значение многочлена в точке `x`.
Для приведенного примера ответ будет 5. Т.е. необходимо написать выражение через `a` и `x`,
которое считает значение многочлена `a` в точке `x`.
__Замечание__: в Octave есть функция `polyval`, делающая аналогичные действия, но у нее иначе интерпретируются
аргументы. Не пользуйтесь этой функцией при решении задачи.
1. Дана матрица-столбец x. Создать квадратную матрицу такого же размера, которая в i-ой строке
и j-ом столбце содержит разность `x(i) – x(j)`.
1. Дана матрица, состоящая из трех столбцов. Предположим, что каждая строка задает прямую вида \\(ax + by + c = 0\\),
где столбцы — это, соответственно, числа `a`, `b`, `c`. Создайте матрицу, состоящую из двух столбцов с числами,
соответственно, `k` и `b`, которые описывает эти же прямые, только в виде \\(y = kx + b\\). Например, строка `[1 1 1]`
должна превратиться в строку `[-1 -1]`.
1. Функция `all2dets(x)`. Дана матрица `x` из двух столбцов. Создать квадратную матрицу,
размером в количество строчек исходной.
Элемент в i-ой строке j-ом столбце должен быть равен определителю матрицы `[x(i,:); x(j,:)]`, т.е. матрицы 2x2,
составленной из i-ой и j-ой строк исходной матрицы. Напомню, что определитель матрицы
\\(\\begin{pmatrix}a&b\\\\c&d\\end{pmatrix}\\)
равен \\(ad - bc\\).
1. Функция `all_lines_intersections(a)`. Дана матрица `а` из трех столбцов, описывающая набор прямых
(см. предыдущее задание). Если кратко сформулировать условие, то нобходимо пересечь каждую прямую с каждой.
Подробней так: каждое пересечение прямой из строки i с прямой из строки j дает две координаты пересечения x и y.
Функция должна вернуть две матрицы `x` и `y`. Первая содержит x координату этого пересечения в строчке i
и столбце j, вторая содержит, соответственно, y координату. Не обрабатывайте отдельно случаи параллельных прямых,
пусть для параллельных прямых получается произвольный ответ, скорее всего, у вас это будет NaN из-за деления 0 на 0.
Напомню формулу пересечения прямых \\(a_1x+b_1y+c_1\\) = 0 и \\(a_2x+b_2y+c_2 = 0\\):
    ```
    Δ = det([a1 b1; a2 b2])
    Δx = det([-c1 b1; -c2 b2])
    Δy = det([a1 -c1; a2 -c2])
    x = Δx / Δ
    y = Δy / Δ
    ```
Соответственно, пользуйтесь задачей 4 для решения.

## Системы уравнений

наполняется...