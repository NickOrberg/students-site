---
type: tasks
---

# R basics `r-basics`. ***Дедлайн среда 11 декабря, 23:59***

1. Даны целые числа `n` и `size`, создайте вектор из повторяющихся чисел от `1` до `n` размера `size`, например,
  `task1(3, 10)` должно вернуть `c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1)`.
1. Даны целые числа `n` и `size`. С помощью функции `sample` сгенерируйте вектор из случайных целых чисел от `1` до `n` и верните его.
   С помощью функций `table` и `print` выведите на экран, сколько раз сгенирировалась какое число.
1. Дан вектор и число `k`. Удалите из вектора все вхождения этого числа.
1. Дано целое число `steps`, сгенерируйте вектор длины `steps` состоящий из чисел 1 и -1. Верните сумму чисел.
1. Смешанное распределение. Дано число `size`. Сгенерируйте вектор размера `size` по следующему алгоритму: чтобы получить очередное число,
   вектора сначала бросается монетка, в одном случае нужно сгенерировать число из распределения \\(N(0, 1)\\). Во втором случае из
   экспоненциального распределения с \\(\\lambda=1\\)
1. Сгенерируйте числовые вектора размера 1000, они указаны в конце задания. Для каждого вектора с помощью t-теста проверьте,
   верно ли, что матожидание равно нулю. Используйте функцию `t.test`. Потом сравните с помощью двухвыборочного t-теста
   (это та же самая функция t.test) каждую пару векторов и проверьте верно ли, что матожидания этих векторов совпадают.
   Функция ничего не должна возвращать, но должна печатать информацию на экране с помощью `print`.
   Разберитесь с информацией, которую выводит функция t.test, т.е. поймите всё, что она выводит.
   Не забудьте посмотреть помощь по этой функции, чтобы правильно выбрать набор аргументов.
   Необязательное задание, попробуйте разобраться, как в программе извлечь результат вызова t.test и автоматически проверить,
   попадает ли выборочное матожидание в доверительный интервал, т.е. можно ли принять гипотезу о равенстве матожиданий.
     * x = равномерно распределенные числа в отрезке от -1 до 1
     * y = нормально распределенные числа со средним 0 и стандартным отклонением 1
     * z = нормально распределенные числа со средним 0 и стандартным отклонением 10
     * t = нормально распределенные числа со средним 0.01 и стандартным отклонением 1

### Моделирование процессов `r-simulations` ***Дедлайн среда 11 декабря, 23:59***

1. А теперь случайное блуждание на плоскости. Дано целое число steps. Сгенерируйте матрицу размера 2 на steps.
   Каждый столбик может быть одним из четырех вариантов: (1 0), (-1 0), (0 1), (0 -1). Теперь получите сумму чисел в первой
   строке, и сумму чисел во второй строке. Это координаты того, куда приблуждало блуждание. Верните вектор из двух этих чисел
1. Дано целое число n, запустите предыдущую задачу n раз, получите n точек и изобразите их на графике.
1. Киндер сюрприз `kinder.R`. Дано $n$ и $T$. представьте, что вы каждый день покупаете шоколадное яйцо с сюрпризом и собираете
игрушки внутри. Всего есть $n$ разных игрушек. Смоделируете выпадание случайной игрушки и дождитесь, когда выпадут
все $n$ разных игрушек хотя бы по одному разу. Сколько прошло дней? Смоделируйте процесс $T$ раз и верните среднее
арифметическое количества дней. Если сможете придумать формулу, которая по $n$ возвращает математическое ожидание числа
дней, когда попадуются все $n$ игрушек, то сравните ее результат с результатом моделирования.  

**Серия задач про Пуассоновский поток**

В этой серии задач считаем, что в ресторан быстрого питания периодически приходят посетители. Мы попробуем смоделировать
моменты времени, когда они приходят, проанализируем, и посмотрим, выполняются ли некоторые утверждения из теории вероятности
про потоки событий подобного рода.

{:start="4"}
1. Даны числа $T$ (общее время эксперимента, типичное значение 1000 секунд), $\\delta t$
(единичный промежуток, типичное значение 0.01), $\\lambda$ (среднее количество событий в секунду, например, 3, т.е. три
посетителя в секунду).
Сгенерируйте вектор с моментами событий, выбирая случайным образом для каждого промежутка размера dt, произошло в нем
событие или нет. Соответственно, вы должны сгенерировать случайный вектор из логических значений размера $\\frac{T}{\\delta t}$,
а вернуть вектор из тех моментов времени, когда сгенерировалась истина.
1. Теперь снова сгенерируем момменты прихода посетителей, но по-другому. Даны числа $T$ и $\\lambda$
(смысл аналогичен прошлому заданию). Сгенерируйте вектор с моментами событий. Для этого генерируйте размеры интервалов
между событиями как равномерно распределенные числа на интервале от 0 до $\\frac{1}{\\lambda}$$. Т.е. первое число - это
момент прихода первого посетителя. Второе число — это время между приходиом первого и второго. Третье число — время от прихода
второго до прихода третьего. И т.д.
1. Дан вектор моментов событий, полученный одним из двух способов. Для каждого целого единичного отрезка (от k до k + 1 при
целом k) посчитайте, сколько в нем произошло событий. Верните результат в виде вектора.
1. Дан вектор моментов событий, полученный одним из двух способов. Верните вектор с интервалами между соседними событиями.
1. Не дано ничего. Создайте вектор моментов событий первым способом. Постройте две диаграммы друг рядом с другом
(графический параметр `mfcol`), на первой диаграмме гистограмма распределения количества событий за единичный
промежуток времени. Дорисуйте на нее же плотность распределения пуассона, сравните диаграмму и плотность, они должны
быть очень похожи. На второй диаграмме нарисуйте гистограмму распределения интервалов между событиями. Дорисуйте на нее
плотность экспоненциального распределения. Они должны оказаться очень похожими.
1. Задание аналогично 5, но генерируйте вектор моментов событий вторым способом. Обратите внимание, что распределения
пуассона и экспоненциальное распределение перестали подходить. А вы сможете придумать распределения, которые подойдут?

### Дата фреймы `r-data-frames` ***Дедлайн среда 11 декабря, 23:59***

1. Напишите один скрипт `task1.R` со следующими действиями:
    1. Сохраните в переменную `cars` дата фрейм `Cars93` из библиотеки `MASS`.
    1. Добавьте в переменную `cars` столбец `kpl` (километров в литре), используйте для вычисления столбец `MPG.city` (миль в галлоне)
    1. Отберите все машины с лошадиной силой (столбец `Horsepower`) более 200.
    1. Выведите график с зависимостью Horsepower (лошадиных сил) от kpl (километров в литре). Это график из нескольких точек в осях Horsepower и kpl. Установите содержательные подписи к осям. Добвьте линию линейной регрессии.
    1. Создайте копию дата фрейма cars, в котором оставлены только столбцы Horsepower, kpl и wt (вес в тоннах, используйте для этого исходный столбец `Weight`, который содержит вес в фунтах). Передайте эту копию в качестве единственного аргумента функции plot. Что вы видите на построенном графике?
1. Напишите один скрипт (не функцию) `task2.R`.
    1. Создайте новый дата фрейм про шарики. У него должно быть два столбца size и color. Первый — это фактор с уровнями "big", "small", второй — фактор с уровнями "red", "green", "blue". Заполните фрейм тысячей независимых равномерно распределенных случайных значений.    
    1. Примените к полученному дата фрейму функцию `table`, функцию `summary`, функцию `plot`. Сколько в нем больших зеленых шариков?
    1. Добавьте столбик weight (вес), это должны быть нормально распределенные случайные числа, причем при генерации чисел используйте разные мат. ожидания для шариков разных размеров.
    1. Снова вызовите функции table, summary, plot для полученного фрейма. Что они показывают?