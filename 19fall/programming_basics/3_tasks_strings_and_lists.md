---
type: tasks
---

# Задачи, часть 3. Операции со строками и другими последовательностями

При решении следующих задач не пользуйтесь ничем, что мы еще не проходили.
Например, мы еще не умеем еще полноценно пользоваться циклами,
мы только можем перебирать натуральные числа.
И старайтесь вообще не пользоваться циклами там, где они не нужны.

1. Дана строка, проверьте, является ли она палиндромом. Т.е. верно ли, что если ее прочитать с конца в начало, то получится та же строка.
    * Добавьте в функцию второй логический параметр strict, если он False, то при проверке нужно игнорировать регистр букв и пробелы.
1. Дана строка, проверьте, верно ли, что в ней все символы идут парами одинаковых. Например, для строки `aaBBccDD55**` нужно вернуть `True`, а для строки `aaBBcC**hF` нужно вернуть `False`.
1. Дана строка, состоящая из букв (это можно не проверять в функции, вам это гарантируется). Проверьте, что регистр букв чередуется. Например, подходит строка `aBsTjU` и `aBa`, но не подходят `aBBa` и `FFFFa`.
1. Напишите функцию, которой дается строка. Она должна поменять местами все использования 0 на 1, а все использования 1 на 0. Например,
`abc01xyz000111` должно превратиться в `abc10xyz111000`.
    * Добавьте в функцию два параметра: символы для замены. Т.е. заменять можно не только 0 на 1 и наоборот, а любой символ на любой. На самом деле, решить нужно эту задачу. А вариант с 0 и 1 нужен только для тренировки.
    * Чтобы решить задачу, попробуйте разобраться либо в методе `replace` для строк. Либо в паре методов `translate` и `maketrans`. Второй вариант предпочтительней, но чуть сложнее, чтобы разобраться.
1. Кривая дракона. В функцию передается один аргумент, целое число \\(n\\ge0\\). Если передан 0, нужно вернуть строку `R`. Иначе нужно повторить \\(n\\) раз следующую операцию: допустим, на предыдущем шаге мы получили строку \\(S\\). Нужно к ней приписать букву `R`, а потом приписать снова \\(S\\), но, во-первых, прочитанную с конца, а, во-вторых, в которой буквы `R` заменены на буквы `L` и наоборот. Например, при \\(n=1\\) получается `RRL` как `R` + `R` + `L`, при \\(n=2\\) получается `RRLRRLL` = `RRL` + `R` + `RLL` и т.д.
    * В качесте необязательного дополнения: подключите библиотеку `turtle`, разберитесь в ней и заставьте черепаху двигаться по полученным в этой задаче правилам. Она идет на фиксированное расстояние, потом поворачивается направо или налево в зависимости от очередной буквы в строке, потом снова идет на такое же расстояние, и процесс продолжается.
1. Коды Грея, часть 1. Создайте функцию, в которую передается один аргумент, целое число \\(n\\ge0\\). Если передан 0, нужно вернуть список `[0]`. Иначе нужно повторить \\(n\\) раз следующую операцию: приписать список из предыдущего шага к самому себе, вставив в середине число с номером шага. На примере это выглядит так:
```
n = 0     [0]
n = 1     [0 1 0]
n = 2     [0 1 0 2 0 1 0]
n = 3     [0 1 0 2 0 1 0 3 0 1 0 2 0 1 0]
...
```
1. Коды Грея, часть 2. Создайте функцию, в которую передается один аргумент, целое число \\(n\\ge0\\). Нужно вызвать функцию из прошлой задачи с аргументом \\(n - 1\\) и запомнить полученный список в переменную `positions`. Дальше вы создаете список `gray` из \\(n\\) нулей и начинаете перебирать элементы `positions`. Каждый элемент `positions` говорит, по какому индексу в списке `gray` нужно заменять 0 на 1 или 1 на 0. Все полученные списки `gray` нужно собрать в один большой список и вернуть его. Например, при \\(n = 3\\) должен получиться результат:
```
[
    [0, 0, 0],
    [1, 0, 0],
    [1, 1, 0],
    [0, 1, 0],
    [0, 1, 1],
    [1, 1, 1],
    [1, 0, 1],
    [0, 0, 1]
]    
```

## Изменяемые объекты
1. Создайте функцию `list_of_empty_lists(n)`, которая возвращает список из пустых список длины `n`.
1. Создайте функцию, которая получает на вход список и меняет местами первый и последний элемент. Эта функция должна возвращать новый список, не меняя исходный.
1. Решите предыдущую задачу, но функция не должна ничего возвращать, зато должна изменять переданный список.

## Генераторы списков: `[expr for x in list if condition]`
Задачи этого раздела нужно решать только с помощью list comprehensions
1. Дан список чисел, верните новый список, где все элементы возведены в квадрат.
1. Дан список чисел, верните новый список, в котором из исходного списка удалены все четные элементы.
1. Дан список строк, верните новый список, в котором все строки превращены в целые числа (используйте функцию `int`), но нужно проигнорировать те строки, которые не являеются числами. Например, `['1', 'a', '42']` должно превратиться в `[1, 42]`. Используйте метод `isdigit()` для строк, чтобы проверить, что строка состоит только из цифр.
1. Дан список, верните новый список, в котором каждый элемент повторен дважды. Например, `[1, 2, 'x']` -> `[1, 1, 2, 2, 'x', 'x']`
1. Решето эратосфена (простой, но не самый эффективный способ).
    1. Напишите функцию, которая по числу \\(k\\) и списку возвращает новый список, в котором удалены все элементы, делящиеся на \\(k\\).
    1. Дано \\(n\\). Создайте список `ints` чисел от 2 до \\(n\\) (оберните range в list). Пока список не пуст, доставайте из него первый элемент \\(p\\). Сохраните этот элемент в список `primes`. Вызывайте предыдущую функцию: `ints = filter_k(ints, p)`. Верните список `primes` и проверьте, что это получились простые числа. Для реализации алгоритма вам понадобится цикл `while`.
1. Дано число \\(n\\), создайте список из всех его положительных делителей. Для этого переберите все числа от 1 до \\(n\\).
     1. Эффективней перебирать числа от 1 до \\(\\sqrt{n}\\), при этом, если получился делитель \\(d\\), то \\(\\frac{n}{d}\\) это тоже делитель. Найдите список всех делителей этим способом.
1. Проверьте число на простоту

